A) Player kinematics & physiology
Inputs available:
Physicals: Max Speed (km/h), # Sprints, # Speed Runs, Total Duration (min)
Events: timestamps (match_run_time_in_ms, event_end_time_in_ms), event, event_type, pressure, positions (x_location_*, y_location_*), to_player_*, team_name, from_player_*
We need to synthesize: v_i_max, a_i_max, d_i_max, tau_i_react, tau_i_turn, f_i(t) (+ GK extras)
v_i_max (cap)
From physicals: v_i_max = Max Speed (km/h) / 3.6 (m/s).
If missing: team median of available players; fallback 8.6 m/s.
a_i_max, d_i_max (caps, tied to physicals)
Estimate time to 85% top speed from sprint count proxy:
t85_i = clamp(2.2 − 0.01 * (# Sprints), 1.6, 2.2) [s]
a_i_max = 0.85 * v_i_max / t85_i
d_i_max = 1.25 * a_i_max (braking > accel).
Clamp biomechanically: a_i_max ≤ 6.5 m/s², d_i_max ≤ 8.0 m/s².
tau_i_react, tau_i_turn (base latencies)
Use role-agnostic bases: tau_i_react, tau_i_turn ∈ [0.20, 0.40] s.
Personalize by speed endurance proxy: scale down (faster) with more sprints:
tau_i_react = 0.26 − 0.002 * min(20, # Sprints) → clamp [0.18, 0.30]
tau_i_turn = 0.34 − 0.002 * min(20, # Sprints) → clamp [0.26, 0.40]
If goalkeepers detected (see GK below), add +0.02–0.04 s.
f_i(t) (fatigue multiplier, event-driven two-reservoir)
Maintain F_fast, F_slow ∈ [0,1] with exponential recovery between events.
Burst detection (I_burst) from events only:
CARRY: use start→end displacement d (m): bins 4/8/12 m → intensities 0.3/0.6/1.0.
PRESS/DEFENSE: if pressure==True on opponent ball-carrier within 6 s of turnover, add 0.4–0.8 based on closed distance (from positions).
QUICK CHAINS: same player acts ≥2 times within 5 s → +0.3.
I_burst_long = rolling sum over 30 s, normalized to [0,1].
Contact proxy (C) from event/event_type text & tags: regex on event for {FOUL, TACKLE, AERIAL, DUEL, COLLISION}, or body_type includes Header, or opponent opposition_touch around our action → map to {0.2, 0.4, 0.7}.
Updates at event time t_k:
F_fast ← clip(F_fast − α_burst·I_burst − α_contact·C, 0,1)
F_slow ← clip(F_slow − β_burst·I_burst_long − β_contact·C, 0,1)
Recovery between events with τ_fast≈45 s, τ_slow≈600 s; heavy contact (C≥0.7) multiplies τ’s by 1.5 for ~60 s.
Final: f_i(t) = 0.6·F_fast + 0.4·F_slow.
Effective kinematics used by control at time t
v_i^eff(t) = v_i_max · (1 − 0.25·(1 − f_i(t)))
a_i^eff(t) = a_i_max · (1 − 0.40·(1 − f_i(t)))
d_i^eff(t) = d_i_max · (1 − 0.20·(1 − f_i(t)))
tau_i_react^eff = tau_i_react · (1 + 0.50·(1 − f_i(t)))
tau_i_turn^eff = tau_i_turn · (1 + 0.50·(1 − f_i(t))).
GK extras (if needed): tau_GK_react, r_GK, v_dive
Detect GK via events: players with save_type/save_detail or repeated save/goal_kick events; if ambiguous, choose jersey # in {1,13} if present; else the player with max saves or min outfield actions.
Defaults: tau_GK_react = tau_i_react + 0.02 s, r_GK = 3.0 m, v_dive = 6.0 m/s.
B) Ball flight / interaction
Inputs available: pass start/end positions, event timestamps, event/action_type, style/style_additional, body_type.
kappa (ground ball decay)
Estimate per-match from passes with valid event_end_time_in_ms:
For each PASS: distance d, travel time Δt = (end_time − start_time) if both present; else approximate Δt = d / 18 m/s (cap 0.15–1.2 s) for initial fit.
Fit a simple drag model v(t)=v0·e^{−κ t} by minimizing squared error of implied v0 across samples → use global κ_ground (e.g., ~1.0–1.6 s⁻¹).
If timing unusable: set κ_ground = 1.3 s⁻¹.
Launch-speed priors (μ, σ) by event type
PASS: μ = median(d/Δt) from above, trimmed; σ = MAD-scaled.
SHOT: infer μ from shot distance with cap 28–32 m/s; σ broad.
CARRY: not used (feet-on-ball).
Height class → interception scaling
AERIAL if (body_type contains “Header”) OR (style/style_additional contains {“High”, “Cross”, “Chip”, “Long Ball”}) → use aerial scaling s_aerial = 1.25 to opponent interception windows; else ground s_ground = 1.0.
delta_ctrl (first-touch delay)
Base 0.18 s; increase under pressure: delta_ctrl = 0.18·(1 + 0.35·1{pressure}).
C) Pitch & coordinate system
Inputs available: positions in either normalized [0,1] or meters; half_time, possibly direction.
pitch_length_m, pitch_width_m
If positions look ≤ 1.2 in magnitude → treat as normalized; set (105, 68) and scale. Else assume meters and compute min/max to verify.
attacking_direction per half
If direction column exists with left/right semantics, use it. Else infer: sign of median Δx for successful passes in that half.
Analysis grid G & weights w(z)
Choose nx=36, ny=24, uniform cell weights; configurable.
D) Pitch-control / reachability parameters
Inputs available: effective kinematics from (A), grid from (C).
beta_ctrl (logistic slope), tau_ctrl (soft aggregation temp)
Set beta_ctrl=2.5, tau_ctrl=0.35 (stable defaults; tune later).
Interception anisotropy (forward/lateral/back)
Use multipliers {1.0, 0.85, 0.75}; direction = player’s current motion toward attacking goal (use imputed lane orientation).
epsilon_TTR floor & physical caps
TTR ≥ 0.05 s; speed/accel never exceed caps in (A).
E) Success models (probabilities)
Inputs available: event geometry, outcome, pressure, line_break_*, body_type, direction, style/_additional.
We’ll build heuristic logits from the current match’s own events (no external training). Baselines come from empirical frequencies by coarse bins; then apply shape constraints.
P_pass(i→j)
Features: distance d, pass angle favorability cosθ (toward goal or receiver lane), pressure (0/1), height class (ground/aerial), line-break intent (direction).
Model:
logit P = α0 + α1·(−d) + α2·cosθ + α3·(−pressure) + α4·1{aerial} + α5·1{line_break_direction aligns with pass}
Initialize α from within-match binning:
α0 = logit(p_base) where p_base = (# completed passes)/(# passes)
Set α1 < 0, α2 > 0; magnitudes from differences in bin means; clip so P∈[0.05, 0.98].
P_carry
Features: carry length d_c, pressure, opponent density proxy (from G below), central-third indicator.
logit P = β0 + β1·(−d_c) + β2·(−pressure) + β3·(−density); initialize from carry outcomes.
P_takeon
Features: angle vs defender, space ahead (low density), pressure.
Start at 0.45 baseline; subtract with more density/pressure; add if attacker moves to open lane.
P_shot (xG-lite)
Features: distance to goal, angle to goal mouth, body type header vs foot, pressure.
logit P = γ0 + γ1·(−dist_m) + γ2·angle_to_goal + γ3·1{Header} with γ3 < 0 typically; initialize from shots in match; if sparse, use defaults (~0.1 at 16m center, tapering with distance).
Calibration: keep identity mapping initially (no Platt/Isotonic); cap extremes, enforce monotone distance effect by re-binning if necessary.
F) Decision policies
Inputs available: event_type, event, sequence_type, game_state, pressure, geometry; per-zone counting.
Acting policy π(a|s) (pass/carry/shot & target choice)
For each zone (grid cell or third) and phase (open play, set play from sequence_type): compute empirical distribution over actions from events.
Target choice for pass: choose teammate j with probability ∝ softmax(η·score(i→j)) where score = (distance favorability + angle + line_break gain − pressure penalty). η = temperature tuned so entropy ≈ observed.
Opponent policy π_opp
Mirror acting team proportions by zone with a small press bias: if opponent is in middle third and pressure flagged frequently, increase pressing/duel propensity by +10%.
Risk/exploration ρ
Base ρ=0.6; modulate with game_state: losing → +0.1 after 70’, winning → −0.1.
G) Pressure / hazard field
Inputs available: pressure flag on events, team_units_broken, total_team_units, line_break_direction/outcome, imputed opponent density (from positions), opposition_touch.
Opponent density (events-only imputation)
At each event time, anchor known actors (from/to players) at their x/y and distribute teammates/opponents into role-lanes around centroid lines (use team_shape/team_unit if populated). Smooth in space/time.
Hazard λ(z,t)
Start with logistic of proximity to nearest opponent + global press prior:
λ = σ(δ0 + δ1·(−dist_to_nearest_opponent) + δ2·1{central_third} + δ3·1{pressure_event_nearby}).
Boost in cells where team_units_broken/total_team_units is high and line_break_outcome indicates success.
Values bounded [0,1]; use moving average over 2–4 s to avoid flicker.
H) Uncertainty & calibration
Inputs available: none explicit (no tracking noise). We fix hyperparameters.
Position noise σ_pos = 0.6 m; ball noise σ_ball = 0.4 m.
Monte Carlo: N_mc = 50, horizon H = 4, discount γ = 0.9.
Calibrators g_*: identity (slots reserved).
Conformal α: report nominal only (no held-out residuals yet).
I) Game/clock integration
Inputs available: events timestamps; physicals Total Duration (min).
frame_rate_hz, timebase alignment → N/A (events-only).
On-pitch availability map
For each player, mark on from first to last event; if physicals duration differs by >5 min, extend nearest side proportionally to match Total Duration (min).
If substitutions are explicitly encoded in game_involvement or origin fields, use those to set precise on/off times.
Column-to-feature dictionary (for quick wiring)
Geometry/time: x_location_start/end, y_location_start/end, match_run_time_in_ms, event_end_time_in_ms, half_time
Entities: team_name, from_player_name/id, to_player_name/id
Context/tags: pressure, line_break_direction/outcome, team_shape, team_unit, total_team_units, sequence_type, game_state, style, style_additional, body_type, direction, opposition_touch, action_type
Physicals: Max Speed (km/h), # Speed Runs, # Sprints, Total Duration (min)
Guardrails (enforced everywhere)
Physical coherence: speeds/accels never exceed caps derived from Max Speed (km/h) & sprint proxy; TTR ≥ 0.05 s.
Smoothness: team control fields via softmin/softmax; hazard via short moving averages.
Monotonicity: longer distances ↓ P_pass/P_carry/P_shot; better angles ↑.
Probability conservation: at each cell, p_T + p_O = 1 (post-blend).
